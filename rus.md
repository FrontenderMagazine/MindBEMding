Погружение в БЭМ — Понимание БЭМ синтаксиса
================================================================================

<q>«Что означают `--` и `__` в названиях ваших классов?»</q> — один из самых
часто задаваемых мне вопросов.

Ответом будет —  спасибо [БЭМ][1] и
[Николасу Галлахеру][2]…

---

БЭМ — аббревиатура от слов *Блок*, *Элемент*, *Модификатор* — методология
именования, изобретённая парнями из [Яндекса][3]. Это изящный путь именования
классов с целью сделать их понятнее и прозрачнее для других разработчиков.
Этот способ строг и информативен, что делает БЭМ идеальной системой для групп
разработчиков на больших проектах.

Важно отметить, что я использую систему именования основанную на БЭМ, но
изменённую предложениями [Николаса Галлахера][4] Система именования, освещаемая
в текущем посте, не является оригинальной БЭМ системой, но улучшенной её
версией, которая мне больше нравится. Тем не менее, в независимости от
фактических изменений в обозначениях, улучшенная версия основана на тех же
принципах БЭМ.


Система именования использует такой шаблон:

~~~~ .language-css
.block{}
.block__element{}
.block--modifier{}
~~~~

* `.block` — самый высокий уровень абстракции или компонента.
* `.block__element` — дочерний элемент `.block` помогающий сфомировать `.block` как монолитный элемент.
* `.block--modifier` — состояние отличное от стандартного или другая версия `.block`.

Двойные символы используются вместо одиночных из-за того, что класс может быть
сам по себе разделён дефисом, например:

~~~~ .language-css
.site-search{} <span class="code-comment">/* Блок */</span>
.site-search__field{} <span class="code-comment">/* Элемент */</span>
.site-search--full{} <span class="code-comment">/* Модификатор */</span>
~~~~

Цель БЭМ — рассказать другим разработчикам как можно больше о том, что делает
кусок кода, только по названиям классам в разметке. Читая HTML с небольшим
количеством классов внутри, вы можете увидеть взаимодействия во всем коде и
между его частями; что-то может быть компонентом, что-то дочерним элементом —
*элементом* этого компонента, а что-то может быть измененной копией —
*модификатором* компонента.

Подумайте как следующие селекторы могут быть связаны:

~~~~ .language-css
.person{}
.person__hand{}
.person--female{}
.person--female__hand{}
.person__hand--left{}
~~~~

Верхний блок это человек (`.person`), имеющий элементы, к примеру руки
(`.hand`). Человек может быть разным, например женского пола (`.female`), и эта
вариация, в свою очередь имеет свои элементы. Ещё раз, тоже самое, но записанное
в «обычном» CSS:

~~~~ .language-css
.person{}
.hand{}
.female{}
.female-hand{}
.left-hand{}
~~~~

Все эти классы имеют смысл, но выглядят несколько разобщёнными. Расмотрим
`.female`; к чему относится класс `female`? Что насчёт `.hand`? Может быть это
дверная ручка или письменная? Используя БЭМ мы можем быть более подробными и в
то же время более точными; мы связываем конкретные классы с не менее конкретными
 элементами в разметке, используя для этого только названия классов. Очень круто.

Давайте рассмотрим пример формы поиска на сайте ещё раз:

~~~~ .language-markup
<form class="site-search  full">
    <input type="text" class="field">
    <input type="Submit" value ="Search" class="button">
</form>
~~~~

Эти классы достаточно нейтральные и ни о чём нам не говорят. Даже несмотря на
то, что мы можем это использовать, эти классы очень не точны. С БЭМ синтаксисом
всё преображается:

~~~~ .language-markup
<form class="site-search  site-search--full">
    <input type="text" class="site-search__field">
    <input type="Submit" value ="Search" class="site-search__button">
</form>
~~~~

Теперь видно, что у нас есть блок названный `.site-search`, у которого есть
вложенный элемент `.site-search__field`. Также наглядно видно, что существует
модификаци блока `.site-search` имеющая свой собственный класс `.site-search--full`.

Давайте рассмотрим ещё один пример…

Если вы знакомы с OOCSS, то не возникнет трудностей и с абстракцией
[медиа объекта][5].

Обретая форму БЭМ, медиа объект теперь выглядит так:

~~~~ .language-css
.media{}
.media__img{}
.media__img--rev{}
.media__body{}
~~~~

Используя такой способ записи стилей, мы уже знаем, что `.media__img` и
`.media__body` находят внутри `.media` и также то, что `.media__img--rev` это
небольшая модификация `.media__img`. И это информация полученная только по
названиям селекторов!

Другим плюсом является ясность взаимосвязей внури разметки. Рассмотрим пример с
медиа объектом ещё раз:

~~~~ .language-markup
<div class="media">
    <img src="logo.png" alt="Логотип «Рога и копыта»" class="img-rev">
    <div class="body">
        <h3 class="alpha">Добро пожаловать в компанию «Рога и копыта»</h3>
        <p class="lede">«Рога и копыта» — молодая, динамично развивающаяся компания</p>
    </div>
</div>
~~~~

Из этого кода, мы никогда не сможем понять как классы `.media` и `.alpha`
относятся к друг другу. Да и относятся ли? А что насчёт классов `.body`,
`.lede` или `.img-rev` и `.media`? Из представленного HTML кода невозможно
представить, что есть компонент сам по себе, а что есть дополнительные элементы
и опции. Если мы переделаем код для работы с БЭМ:

~~~~ .language-markup
<div class="media">
    <img src="logo.png" alt="Логотип «Рога и копыта»" class="media__img--rev">
    <div class="media__body">
        <h3 class="alpha">Добро пожаловать в компанию «Рога и копыта»</h3>
        <p class="lede">«Рога и копыта» — молодая, динамично развивающаяся компания</p>
    </div>
</div>
~~~~

Теперь мы можем мгновенно увидеть, что `.media` — блок, а `.media__img--rev`
элемент блока `.media`, этот элемент также имеет модификатор; также ясно видно,
что `.media__body` — неизмененённый элемент блока `.media`. Вся картина
взаимосвязей успешно складывается по именам классов.
Это **невероятно** удобно и полезно.

## Уродливость! ##

Частым аргументов против БЭМ является его уродливость; Я буду смелым,
если скажу, что если вы даже не пытаетесь использовать код, аргументируя тем,
как он выглядит, то вы не поняли главного смысла обсуждаемой методологии.
Пока поддержка или читаемость кода внезапно не стали осложнять вам жизнь,
вы *должны* дважды подумать, перед тем, как начать использовать методологию.
Но если БЭМ только «странно выглядит», но выполняет вашу задачу, вы обязательно
должны подумать о том, чтобы внедрить его к себе в проекты.

Я согласен с тем, что БЭМ выглядит немного странно, но сила и мощь,
которые он с собой приносит намного перевешивают недостатки, связанные с его
внешним видом.

БЭМ может выглядить смешным — и он вынудит вас больше печатать (большинство
редакторов имеют автодополнение, а минификация скроет разницу в размерах
файлов) — но он **очень** мощный.

## БЭМ’ить или не БЭМ’ить? ##

Я использую БЭМ синтаксис в любом проекте, что создаю, и свою полезность он
доказывает каждый раз. Я призываю всех подумать о принятии БЭМ, потому что он
крепче связывает CSS и HTML, и позволяет создавать легко поддерживаемый код не
только для команд, но и для самого себя спустя полгода.

Тем не менее, при использовании БЭМ, важно помнить, что нет нужды использовать
его повсюду, например:

~~~~ .language-css
.caps{ text-transform:uppercase; }
~~~~

Этот CSS никогда не поместить в БЭМ методологию, это просто одиночное правило.

Другой пример:
~~~~ .language-css
.site-logo{}
~~~~

Это наш логотип; он может быть преобразован так:

~~~~ .language-css
.header{}
.header__logo{}
~~~~

Но это не является необходимым. Фишка БЭМ’а в правильном распределении дочерних
элементов. Не все вложенные элементы являются БЭМ *элементами* на самом деле.
В примере с шапкой сайта и логотипом, логотип находится в шапке, но это
не мешает ему с легкостью оказаться в одной из колонок или в подвале сайта.
Пространство имён БЭМ элемента может начаться в любом месте, поэтому будьте
аккуратны и применяйте БЭМ только в тех местах, в которых вы нуждаетесь.
Другой пример:

~~~~ .language-markup
<div class="content">
    <h1 class="content__headline">Можно предположить, что лемма проецирует…</h1>
</div>
~~~~

Возможно нам нужно было назвать второй класс `.headline`; это зависит от того,
зависит ли оформление от того, что заголовок находится в `.content` или
он просто случайно оказался в `.content` области. Если второе, то в этом
случае вам не нужен БЭМ в этом примере.

Абсолютно всё готово к изменению под БЭМ. Рассмотрев пример с логотипом ещё
раз, представьте, что вы хотите сделать праздничную версию логотипа для
рождественского дизайна сайта. Мы можем сделать так:

~~~~ .language-css
.site-logo{}
.site-logo--xmas{}
~~~~

Мы можем бысто создавать разные варианты, используя `--` синтаксис модификатора.

Одни из самых трудных частей БЭМ — выбор, когда начать и когда закончить
пространство очередного БЭМ блока и вопрос надобности использования методологии
в каждом конкретном случае. Это одни из тех моментов, когда понимание этого
знания придёт само.

## Последнее слово ##

Итак это БЭМ (или его небольшая модификация); очень полезная, мощная и простая
методология именования, позволит сделать ваш код на фронтенд стороне
более простым, читабельным, легче в работе, масштабируемым без головной боли,
более надёжным, явным и гораздо более строгим и структурированным.

Для всех БЭМ выглядит немного странно, но это без сомнения огромное и важное
дополнение в копилку инструментов фронтенд разработчика, в не зависимости от проекта.

 [1]: http://bem.info "BEM"
 [2]: http://twitter.com/necolas "@necolas"
 [3]: http://yandex.ru "Яндекс"
 [4]: http://nicolasgallagher.com/about-html-semantics-front-end-architecture/ "About HTML semantics and front-end architecture"
 [5]: http://stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code "The media object saves hundreds of lines of code"

